<?xml version="1.0" encoding="utf-8"?>
<Coverity.Prevent.Desktop.Configuration>
  <Version>7.1.1</Version>
  <DataBase>
    <UseSSL>false</UseSSL>
    <SavePassword>true</SavePassword>
    <RemoteDbLocation />
    <RemoteDbPort>8080</RemoteDbPort>
    <UserName />
    <UserPassword />
  </DataBase>
  <CentralAnalysisProject />
  <DefectsFoundBy>
    <DefectsSource>LocalOnly</DefectsSource>
    <LastFoundBy />
    <DefectSourceStream />
    <DefectSourceLanguage />
  </DefectsFoundBy>
  <AnalysisBuildSettings>
    <BuildConfig>
      <BuildWithInstrument>false</BuildWithInstrument>
      <ContinueAnalysisAfterBuildFail>false</ContinueAnalysisAfterBuildFail>
      <BuildOptions />
      <PostBuild />
      <BuildEngine>
        <Name>MSBuild 12.0</Name>
        <BinaryPath>C:\Program Files (x86)\MSBuild\12.0\bin\\MSBuild.exe</BinaryPath>
      </BuildEngine>
    </BuildConfig>
    <AnalysisOptions />
    <PostAnalyze />
    <CommitOptions />
    <PostCommit />
    <UseSolutionCheckers>false</UseSolutionCheckers>
    <ImportMicrosoftCodeAnalysis>false</ImportMicrosoftCodeAnalysis>
    <CheckersOverridenFirstTime>false</CheckersOverridenFirstTime>
    <Checkers>
      <Checker>
        <Name>FORWARD_NULL</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name />
            <Value />
            <Languages />
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT</string>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ALLOC_FREE_MISMATCH</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ARRAY_VS_SINGLETON</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>stat_cutoff</Name>
            <Type>int</Type>
            <Description>C/C++ option that sets the value used by statistical analysis to filter defects. If a singleton pointer is passed to a function, but there are at least this many call sites in the code base where the address of something is passed to that same function (in the same argument position), then no defect is reported. Reducing this value will cause more defects to be reported, and usually more of them will be false positives. Defaults to ARRAY_VS_SINGLETON:stat_cutoff:10</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ASSERT_SIDE_EFFECT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>distrust_functions</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, the checker treats any function call as potentially having a side effect. Consequently, any use of a recognized assert macro with a function call in its condition will be reported as a defect. By default, the checker ignores function calls in assert macros when looking for defects. Defaults to ASSERT_SIDE_EFFECT:distrust_functions:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>macro_name_has</Name>
            <Type>regex</Type>
            <Description>C/C++ option that accepts a regular expression (Perl syntax) to expand the set of recognized assert macros. You can specify more than one of these options on the command line. Defaults to ASSERT_SIDE_EFFECT:macro_name_has:[Aa]ssert|ASSERT</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>macro_name_lacks</Name>
            <Type>regex</Type>
            <Description>C/C++ option that accepts a regular expression (Perl syntax) to restrict the set of recognized assert macros, even if the macro name matches a macro_name_has option (including the defaults). You can specify more than one of these options on the command line. Default is unset.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ASSIGN_NOT_RETURNING_STAR_THIS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>rule (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ATOMICITY</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>concurrency (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_ALLOC_ARITHMETIC</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_ALLOC_STRLEN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_plus_any</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, the checker will report defects on a buffer allocation that uses the length of a string plus any integer. It reports strlen(p+C) for any constant C, not just 1. By default, it reports a defect only when the length of a string plus one is used. Defaults to BAD_ALLOC_STRLEN:report_plus_any:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_COMPARE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_EQ</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>stat_bias</Name>
            <Type>float</Type>
            <Description>C# option that specifies a floating point number N that is used by the checker to report a defect when (S + N) / (S + R) &lt;= T. Here, S = number of structural comparisons, R = number of referential comparisons, and T = value of the stat_threshold option value. Defaults to BAD_EQ:stat_bias:0.25</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>stat_threshold</Name>
            <Type>float</Type>
            <Description>C# option that reports referential equality comparisons as defects when the specified threshold of structural equality comparisons (a percentage of all equality comparisions) is met or exceeded. For example, -co BAD_EQ:stat_threshold:50 will cause the checker to report a defect on all referential equality comparisons if 50% of the comparisons are structural. Defaults to BAD_EQ:stat_threshold:80</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_EQ_TYPES</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_FREE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_first_field</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, the checker suppresses defect reports on the freeing of the address of the first field of a structure, or the first element of the first field, or the first field of the first field, and so on. Because the address of the first field is the same as the address of the containing object, these constructs are harmless. Defaults to BAD_FREE:allow_first_field:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_LOCK_OBJECT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_OVERRIDE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>virtual</Name>
            <Type>bool</Type>
            <Description>When this C++ option is set to true, the checker will report cases in C++ where a method in a derived class has the same signature as a base class method, but the base class method is not virtual, and therefore not overridden (it is merely hidden). Such a case is suspicious, but it might be intentional. Defaults to BAD_OVERRIDE:virtual:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_SHIFT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_SIZEOF</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_pointers</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, the checker reports defects if a sizeof operator is used to obtain the size of almost any pointer. Defaults to BAD_SIZEOF:report_pointers:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BUFFER_SIZE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_fixed_size_dest</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, the checker reports defects when the destination size is known, but the source size is not (for example, a pointer). These are potential overflows because the source could be arbitrarily large and should be length checked before being passed to the copy routine. By default, defects are not reported unless both source and destination sizes are known. Defaults to BUFFER_SIZE:report_fixed_size_dest:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CALL_SUPER</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_empty_overrides</Name>
            <Type>bool</Type>
            <Description>When this C# and Java option is set to false (default for C#), the checker will not report a defect on a method with an empty implementation (as in { }) because the developer might have intended that the method not call super. When true (default for Java), empty methods are are treated like non-empty methods are treated. Defaults to CALL_SUPER:report_empty_overrides:true (for Java). Defaults to CALL_SUPER:report_empty_overrides:true (for C#).</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>threshold</Name>
            <Type>float</Type>
            <Description>This C# and Java option sets the minimum fraction of method overriders that must call the base class implementation before defects are reported on those that do not. For &lt;ratio&gt;, enter a floating point number between 0 and 1. Defaults to CALL_SUPER:threshold:.65 (for C# and Java).</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>whitelist</Name>
            <Type>bool</Type>
            <Description>This C# and Java option determines whether CALL_SUPER uses its built-in list of methods whose superclass implementation must be called from overriders. For C#, this list consists of Dispose, Close, and some methods in the System.Windows.Forms API that are documented with the strong suggestion to call the implementation of the base class. For Java, this list consists of clone, finalize, and a number of Android API methods. If true, any overrider of a whitelisted method is expected to call the super implementation, regardless of statistical evidence. Defaults to CALL_SUPER:whitelist:true (for C# and Java).</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CHAR_IO</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CHECKED_RETURN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>error_on_use</Name>
            <Type>bool</Type>
            <Description>When this C/C++ and Java option is set to true, the checker will treat the passing of the return value of one function to the parameter of another, without first checking that value, as a defect (if it concludes that the first function's return value is supposed to be checked). Defaults to CHECKED_RETURN:error_on_use:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>stat_threshold</Name>
            <Type>float</Type>
            <Description>This C/C++ and Java option sets the percentage of call sites to a function that must check the return value in order for the statistical analysis to conclude that all call sites should be checked. The percentage represents the proportion of "correct" code (that is, when function returns are checked) needed to flag "bad" code (function returns that are not checked) as a defect. For example, stat_threshold:85 means that when 85% of function return values are checked, this checker flags the unchecked return values as defects. Defaults to CHECKED_RETURN:stat_threshold:80</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CHROOT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.ADDROF_LEAK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_ccomptr</Name>
            <Type>bool</Type>
            <Description>If this C++ option is set to true, enabled leaks on CComPtr objects are reported. Defaults to COM.ADDROF_LEAK:report_ccomptr:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.BAD_FREE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.BSTR.ALLOC</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.BSTR.BAD_COMPARE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>arith_yields_wchar_t</Name>
            <Type>bool</Type>
            <Description>If this C++ option is set to true, the checker treats any expression &lt;b&gt;+&lt;i&gt; for BSTR &lt;b&gt; and integer &lt;i&gt; as though it has the type wchar_t* (instead of BSTR), which means that the checker will report fewer defects. Defaults to COM.BSTR.BAD_COMPARE:arith_yields_wchar_t:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.BSTR.CONV</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_bstr_arith</Name>
            <Type>bool</Type>
            <Description>If this C++ option is true, the checker treats arithmetic on a BSTR expression as though it produces a result of type wchar_t*, which means that the checker will report more defects. The additional defects might be considered false positives if the resulting pointer is only used in very limited ways, but it is still a questionable practice. Defaults to COM.BSTR.CONV:report_bstr_arith:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COM.BSTR.NE_NON_BSTR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>arith_yields_wchar_t</Name>
            <Type>bool</Type>
            <Description>If this C++ option is set to true, the checker treats any expression &lt;b&gt;+&lt;i&gt; for BSTR &lt;b&gt; and integer &lt;i&gt; as though it has the type wchar_t*, instead of BSTR. Defaults to COM.BSTR.NE_NON_BSTR:arith_yields_wchar_t:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CONSTANT_EXPRESSION_RESULT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_bit_and_with_zero</Name>
            <Type>bool</Type>
            <Description>If this C/C++, C#, and Java option is set to true, the checker treats bitwise AND (&amp;) expressions with 0 as defects. Defaults to CONSTANT_EXPRESSION_RESULT:report_bit_and_with_zero:false (for C/C++). Defaults to CONSTANT_EXPRESSION_RESULT:report_bit_and_with_zero:true (for C# and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_bit_and_with_zero_in_macros</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, the checker treats bitwise AND expressions with 0 as defects, even if they occur entirely within macro expansions. Defaults to CONSTANT_EXPRESSION_RESULT:report_bit_and_with_zero_in_macros:false (for C/C++ only).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_constant_logical_operands</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is set to true, the checker reports constructs where, in a logical AND (&amp;&amp;) or logical OR (||) context, one of the operands is a constant expression. Defaults to CONSTANT_EXPRESSION_RESULT:report_constant_logical_operands:false (for C/C++, C#, and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_constant_logical_operands_in_macros</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, the checker reports the same kind of problems found by the report_constant_logical_operands option, even if they occur entirely within macro expansions. Defaults to CONSTANT_EXPRESSION_RESULT:report_constant_logical_operands_in_macros:false (for C/C++ only).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_unnecessary_op_assign</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is set to true, the checker reports &amp;= or |= operations that assign a constant value and thus can be replaced with a simple assignment. Defaults to CONSTANT_EXPRESSION_RESULT:report_unnecessary_op_assign:false (for C/C++, C#, and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COPY_PASTE_ERROR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>COPY_WITHOUT_ASSIGN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>rule (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>CTOR_DTOR_LEAK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DC.STREAM_BUFFER</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DC.STRING_BUFFER</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DC.WEAK_CRYPTO</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DEADCODE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>no_dead_default</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is set to true, the checker suppresses reports of defects caused by an unreachable default statement in a switch-case statement. Defaults to DEADCODE:no_dead_default:false (meaning that unreachable default statements are reported as defects).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_dead_killpaths</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is set to true, the checker will report "dead" code that represents a "kill path". Kill paths include those that unconditionally throw an exception, call an unconditional assert, or use similar mechanisms. By default, DEADCODE automatically suppresses such reports, treating such mechanisms as intentional, "defensive" coding. Defaults to DEADCODE:report_dead_killpaths:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_redundant_tests</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is set to true, the checker will report cases where a branch cannot be taken, if that does not result in any fragment of code being unreachable. Defaults to DEADCODE:report_redundant_tests:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppress_effectively_constant_local</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is set to true, the checker will suppress a defect on a local variable that is assigned only once to a constant value and used as a condition into a block of dead code (see details below). You use the option to suppress defects that intentionally disable code by means of a local variable. Note that might also suppress some true positives, so use it with caution. Defaults to DEADCODE:suppress_effectively_constant_local:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DELETE_ARRAY</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>no_error_on_scalar</Name>
            <Type>bool</Type>
            <Description>When this C++ option is true, the checker does not report defects when the array element type is a scalar (for example, int). Although it is incorrect, using delete on an array of scalars is harmless in many implementations of C++, so this option is provided to suppress reporting that. Defaults to DELETE_ARRAY:no_error_on_scalar:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DELETE_VOID</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>DIVIDE_BY_ZERO</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ENUM_AS_BOOLEAN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>EVALUATION_ORDER</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>GUARDED_BY_VIOLATION</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>lock_inference_threshold</Name>
            <Type>float</Type>
            <Description>This C# and Java option specifies the minimum percentage of accesses to a global variable or or field of a struct that must be protected by a particular lock for the checker to determine that the variable or field should always be protected by that lock. Variable v is treated as protected by lock l if the proportion of the number accesses of v with l compared to the total number of accesses of v is less than or equal to the percentage you set. If the percentage is set to 50 when two out of four accesses of v occur with l, the checker will issue a defect. If set to 75, such a scenario would not produce a defect report. Defaults to GUARDED_BY_VIOLATION:lock_inference_threshold:70 (for C# and Java).</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>IDENTICAL_BRANCHES</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_different_case_lines</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker will report switch case statements when one case has comments and the other does not, or if the statements use a different number of lines. If the option is false, the checker will not report such issues. Defaults to IDENTICAL_BRANCHES:report_different_case_lines:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_different_ifelse_lines</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker will report if-else branches when one branch has comments and the other does not, or in general, if the branches use a different number of lines. If the option is false, the checker will not not report such issues. Defaults to IDENTICAL_BRANCHES:report_different_ifelse_lines:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_elseif_chains</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker will report else-if chains with identical branches. Defaults to IDENTICAL_BRANCHES:report_elseif_chains:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_switch_cases</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker will report identical case statements in a switch-case structure. Defaults to IDENTICAL_BRANCHES:report_switch_cases:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>switch_case_min_stmts</Name>
            <Type>int</Type>
            <Description>This C/C++, C#, and Java option specifies the minimum number of statements to report in switch case statements. Defaults to IDENTICAL_BRANCHES:switch_case_min_stmts:3</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>INCOMPATIBLE_CAST</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>INFINITE_LOOP</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_asm</Name>
            <Type>bool</Type>
            <Description>If this C/C++ option is enabled, the checker will ignore all assembly code. By default, the checker assumes that assembly code can be a loop control variable update statement. Defaults to INFINITE_LOOP:allow_asm:false (for C/C++ only).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_pointer_derefs</Name>
            <Type>bool</Type>
            <Description>C/C++, C#, and Java option that allows detection of infinite loops involving C/C++ pointer dereferences or, for C# and Java, where the incorrectly-updated variable is a field of another variable. Defaults to INFINITE_LOOP:allow_pointer_derefs:false (for C/C++, C#, and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_no_escape</Name>
            <Type>bool</Type>
            <Description>This C/C++, C#, and Java option reports loops with no escape conditions as defects. By default, the checker does not report loops without escape conditions as defects. Defaults to INFINITE_LOOP:report_no_escape:false (for C/C++, C#, and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppress_in_macro</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to false, the checker will report potential infinite loops where the control condition is within a macro. Defaults to INFINITE_LOOP:suppress_in_macro:true (for C/C++ only), which suppresses such reports.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>INTEGER_OVERFLOW</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>enable_all_overflow_ops</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports defects for subtraction, unary negation, increment, and decrement operations. Defaults to INTEGER_OVERFLOW:enable_all_overflow_ops:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_array_sink</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker treats all array index operations as sinks. Defaults to INTEGER_OVERFLOW:enable_all_overflow_ops:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_const_overflows</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker flags overflows due to arithmetic on constant operands that are either literal constants or are known to be specific constant values along a particular path. Occasionally, such overflows are intentional, but often they indicate a logical error or an erroneous value. Enabling this option flags overflows for the following operators: add, subtract, multiply, truncate due to cast, increment (++), and decrement (--). Defaults to INTEGER_OVERFLOW:enable_const_overflows:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_deref_sink</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker treats the operation of deferencing a pointer as sinks. Defaults to INTEGER_OVERFLOW:enable_deref_sink:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_return_sink</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker treats all return statements as sinks. Defaults to INTEGER_OVERFLOW:enable_return_sink:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_tainted_params</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker treats all operands as potentially tainted. Defaults to INTEGER_OVERFLOW:enable_tainted_params:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>INVALIDATE_ITERATOR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>container_type</Name>
            <Type>regex</Type>
            <Description>This C++ option adds to the list of containers that the checker recognizes. Default is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_map_put</Name>
            <Type>bool</Type>
            <Description>If this Java option is set to true, the checker reports defects involving Map.put. By default, the checker treats Map.put as though it cannot modify a collection. Defaults to INVALIDATE_ITERATOR:report_map_put:false</Description>
            <Languages>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>LOCK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>concurrency (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>LOCK_EVASION</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>LOCK_INVERSION</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>max_lock_depth</Name>
            <Type>int</Type>
            <Description>This C# &amp; Java option specifies the maximum depth of the call chain that acquires the second lock while the first lock is held. This option exists because when the lock acquisitions are separated by a deeply nested call chain, there is often some other synchronization mechanism involved that the analysis cannot interpret, so the resulting reports are often false positives. By default, if a second lock is acquired in a call chain that has more than 6 getlock calls, the analysis will not treat it as a lock acquired when holding another lock. As a consequence, it might suppress a LOCK_INVERSION defect that is associated with that pair. To find such an issue, enable this option by increasing the max_lock_depth value. Defaults to LOCK_INVERSION:max_lock_depth:6</Description>
            <Languages>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISMATCHED_ITERATOR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>container_type</Name>
            <Type>regex</Type>
            <Description>This C++ option specifies an additional set of types to treat as STL containers. A type is treated as a container if its simple identifier (no scope qualifiers) fully (not a substring) matches the specified regular expression, and it has an end() method. You can specify multiple types by separating them with the '|' regex operator. Defaults to MISMATCHED_ITERATOR:container_type:""</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_comparison</Name>
            <Type>bool</Type>
            <Description>When this C++ option is true, the checker will report when iterators from different containers are compared. Defaults to true. Defaults to MISMATCHED_ITERATOR:report_comparison:true (disabled if false).</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISRA_CAST</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_widening_bool</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker suppresses reporting of boolean values cast to wider integer types. Defaults to MISRA_CAST:allow_widening_bool:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_constant_expressions</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports violations within constant expressions. Defaults to MISRA_CAST:check_constant_expressions:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>non_negative_literals_may_be_unsigned</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker changes the MISRA definition of the underlying type of an integer constant such that, if it occurs in a context requiring an unsigned type, an integer literal with a non-negative value is considered to have an unsigned underlying type if its value fits into the required type. Defaults to MISRA_CAST:non_negative_literals_may_be_unsigned:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_BREAK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allowFallthroughCommentAnywhere</Name>
            <Type>bool</Type>
            <Description>This C/C++ and Java option recognizes a comment that starts anywhere on the last line, not just at the beginning, as the fallthrough acknowledgement comment. Defaults to MISSING_BREAK:allowFallthroughCommentAnywhere:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>anyLineRegex</Name>
            <Type>regex</Type>
            <Description>For this C/C++ and Java option, if any line in the case block matches the regular expression string (a Perl regular expression), then that case block is not reported. Defaults to regular expression MISSING_BREAK:anyLineRegex:[^#]fall.?thro?u</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>maxCountdownStartVal</Name>
            <Type>int</Type>
            <Description>This C/C++ and Java option sets the maximum start case value where a switch statement on a length, which represents an incremented pointer, processes counts in reverse order. Defaults to MISSING_BREAK:maxCountdownStartVal:8</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>maxReportsPerFunction</Name>
            <Type>int</Type>
            <Description>This C/C++ and Java option suppresses all defect reports for those functions that exceed the specified maximum number of defects found by the checker. To allow an unlimited number of defects to be reported, specify 0. Defaults to MISSING_BREAK:maxReportsPerFunction:5</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressCountdowns</Name>
            <Type>bool</Type>
            <Description>If this C/C++ and Java option is set to false, the checker will not report a defect when a switch statement on a length processes counts in reverse order. Defaults to MISSING_BREAK:suppressCountdowns:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressIfLastComment</Name>
            <Type>bool</Type>
            <Description>If this C/C++ and Java option is set to false, the checker will not report a defect when the code block for a case ends with a comment. Defaults to MISSING_BREAK:suppressIfLastComment:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressIfSimilarASCII</Name>
            <Type>bool</Type>
            <Description>If this C/C++ and Java option is set to false, the checker will not report a defect when a case falls through to another case that has a similar numeric value when interpreted as ASCII. Values are considered similar when both are whitespace values (such as space, tab, or newline), or the two values are different cases (uppercase or lowercase) of the same letter. Defaults to MISSING_BREAK:suppressIfSimilarASCII:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressIfSucceedingAdjacentPair</Name>
            <Type>bool</Type>
            <Description>If this C/C++ and Java option is set to false, the checker will not report a defect when if the case block is immediately followed by two more case lines with no intervening blank lines. Defaults to MISSING_BREAK:suppressIfSucceedingAdjacentPair:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressOnGuardedBreak</Name>
            <Type>bool</Type>
            <Description>If this C/C++ and Java option is set to false, the checker will not report a defect when the code block for a case includes at least one conditional statement, and at least one of those statements includes a break statement. Defaults to MISSING_BREAK:suppressOnGuardedBreak:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressOnKillpaths</Name>
            <Type>bool</Type>
            <Description>If this C/C++ and Java option is set to false, the checker will not report a defect when the top-level statement in a case is a call to a function that can end the program. Defaults to MISSING_BREAK:suppressOnKillpaths:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressOnNextBreak</Name>
            <Type>bool</Type>
            <Description>If this C/C++ and Java option is set to false, the checker will not report a defect when the case that follows the case with the missing break begins with a break statement. Defaults to MISSING_BREAK:suppressOnNextBreak:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressOnSameLine</Name>
            <Type>bool</Type>
            <Description>If this C/C++ and Java option is set to false, the checker will not report a defect when a case starts and ends on the same line, which often results from macro expansions. Defaults to MISSING_BREAK:suppressOnSameLine:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppressOnTerminatedBranches</Name>
            <Type>bool</Type>
            <Description>If this C/C++ and Java option is set to false, the checker will not report a defect when there is no control flow statement between the start and end cases. Defaults to MISSING_BREAK:suppressOnTerminatedBranches:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_COMMA</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_COPY_OR_ASSIGN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>rule (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_LOCK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>lock_inference_threshold</Name>
            <Type>float</Type>
            <Description>This C/C++ option specifies the minimum percentage of accesses to a global variable or field of a struct that must be protected by a particular lock for the checker to determine that the variable or field should always be protected by that lock. Variable v is treated as protected by lock l if the proportion of the number accesses of v with l compared to the total number of accesses of v is less than or equal to the percentage you set. If the percentage is set to 50 when two out of four accesses of v occur with l, the checker will issue a defect. If set to 75, such a scenario would not produce a defect report. Defaults to MISSING_LOCK:lock_inference_threshold:76</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>concurrency (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_RESTORE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_restore_not_dominated_by_modify</Name>
            <Type>bool</Type>
            <Description>By default the checker only reports cases where the non-local variable is modified along all paths between the point where it is saved and the point where it is restored. Such a modification is said to dominate the restoration. While it is clear that the assignment of the local variable to the non-local is genuinely a restoration in such cases, there are also cases that genuinely restore even without such domination. Enabling this C++, C#, and Java option causes such cases to be reported, but is also likely to report some instances where either no genuine restore is occurring or it was intentional to only restore under some conditions. Defaults to MISSING_RESTORE:report_restore_not_dominated_by_modify:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_uncorrelated_with_return</Name>
            <Type>bool</Type>
            <Description>When the restoration of non-local state is not correlated with the return value of the function or method, there is a greater chance that the behavior is intentional. When set to true, this C++, C#, and Java option expands reporting of software issues to such cases. By default, this option otherwise limits reporting to cases in which the checker can both recognize a pattern in the different return values from the function or method, and establish a correlation between different return values and whether restoration is likely to be expected for any given return value. Defaults to MISSING_RESTORE:report_uncorrelated_with_return:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_RETURN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>ignore_void</Name>
            <Type>bool</Type>
            <Description>If this C/C++ option is set to true, the checker ignores only_one_return cases for functions that do not return a value. (See the only_one_return option for details.) Defaults to MISSING_RETURN:ignore_void:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>only_one_return</Name>
            <Type>bool</Type>
            <Description>If this C/C++ option is set to true, the checker reports cases where a function has more than one return statement. Defaults to MISSING_RETURN:only_one_return:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MISSING_THROW</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>MIXED_ENUMS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_anonymous_enums</Name>
            <Type>bool</Type>
            <Description>If this C/C++ option is set to true, the checker reports the mixing of enumeration constants from unnamed (anonymous) enum types with other enum types. Defaults to MIXED_ENUMS:report_anonymous_enums:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_disjoint_enums</Name>
            <Type>bool</Type>
            <Description>If this C/C++ option is set to true, the checker reports the mixing of different, disjoint enum types. Defaults to MIXED_ENUMS:report_disjoint_enums:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_equivalent_enums</Name>
            <Type>bool</Type>
            <Description>If this C/C++ option is set to true, the checker reports the mixing of different, effectively equivalent enum types. Defaults to MIXED_ENUMS:report_equivalent_enums:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>NEGATIVE_RETURNS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>NESTING_INDENT_MISMATCH</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_bad_indentation</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker will report cases where the indentation does not match the syntactic nesting, but the code is likely to be logically correct. In these cases, the run-time behavior is correct, but the code might continue to be misleading and difficult to maintain. Defaults to NESTING_INDENT_MISMATCH:report_bad_indentation:false (for C/C++, C#, and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>NO_EFFECT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>array_null</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports a check of an array against NULL. Checks in macros are not reported. Defaults to NO_EFFECT:array_null:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>bad_memset</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports defects when suspicious arguments are passed to the memset function. A size argument of 0 can indicate that the size and fill arguments are switched. A fill value outside the range of -1 to 255 will likely lead to truncation. A fill value of 0 is likely intended to be 0. Defaults to NO_EFFECT:bad_memset:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>bool_switch</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports switching on a comparison because this indicates that the assignment was probably intentional. Defaults to NO_EFFECT:bool_switch:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>extra_comma</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports a defect if the left operand of a comma operator has no side effects. Defaults to NO_EFFECT:extra_comma:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>incomplete_delete</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports a defect for the pattern delete a, b. In that pattern, only the first pointer is freed. Defaults to NO_EFFECT:incomplete_delete:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>no_effect_deref</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports useless dereferences of pointers. Defaults to NO_EFFECT:no_effect_deref:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>no_effect_test</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports useless boolean tests. The programmer probably intended to assign, rather than compare, the arguments. Defaults to NO_EFFECT:no_effect_test:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>self_assign</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports assignments of fields and globals to themselves. Defaults to NO_EFFECT:self_assign:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>self_assign_in_macro</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports self assigns where the right-hand side is in a macro. Defaults to NO_EFFECT:self_assign_in_macro:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>self_assign_to_local</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports assignments of locals and parameters to themselves. Defaults to NO_EFFECT:self_assign_to_local:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>static_through_instance</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will NOT report cases where a static field or method is accessed using an instance pointer. Defaults to NO_EFFECT:static_through_instance:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>unsigned_compare</Name>
            <Type>bool</Type>
            <Description>C/C++ option that reports unsigned comparisons against 0, unless the expression's parent is a manual signed cast. Defaults to NO_EFFECT:unsigned_compare:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>unsigned_compare_macros</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports the comparison of an unsigned quantity against 0 in macros. Defaults to NO_EFFECT:unsigned_compare_macros:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>unsigned_enums</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports the comparison of an enum value against 0 as a defect when the underlying type of the enum is unsigned and the result is always the same. Note that the underlying type of an enum is partly defined by the compiler implementation. Defaults to NO_EFFECT:unsigned_enums:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>NON_STATIC_GUARDING_STATIC</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>NULL_RETURNS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_unimpl</Name>
            <Type>bool</Type>
            <Description>This C/C++, C#, and Java option reports unchecked, unimplemented functions (as opposed to only functions that are known to return NULL). Defaults to NULL_RETURNS:allow_unimpl:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>stat_bias</Name>
            <Type>float</Type>
            <Description>This C/C++, C#, and Java option specifies a number to add to the check count that biases the checker to report defects for functions that do not occur often in the program. The value of this option and the stat_threshold option affects the calculation used by the checker to identify defects (see stat_threshold for details). Defaults to NULL_RETURNS:stat_bias:0 (for C/C++). Defaults to NULL_RETURNS:stat_bias:3 (for C# and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>stat_threshold</Name>
            <Type>float</Type>
            <Description>This C/C++, C#, and Java option sets the percentage of call sites that must have their value checked in order for the statistical analysis to conclude that the function or method should always have its return value checked. Defaults to NULL_RETURNS:stat_threshold:80 (for C/C++, C#, and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>suppress_under_related_conditional</Name>
            <Type>bool</Type>
            <Description>This C/C++, C#, and Java option suppresses defect reports that are heuristically identified as being controlled by a condition that is related to the call alleged as returning null. Defaults to NULL_RETURNS:suppress_under_related_conditional:true (for C#). Defaults to NULL_RETURNS:suppress_under_related_conditional:false (for C++ and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>OPEN_ARGS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>ORDER_REVERSAL</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>max_lock_depth</Name>
            <Type>int</Type>
            <Description>This C/C++ option specifies the maximum depth of the call chain that acquires the second lock while the first lock is held. This option exists because when the lock acquisitions are separated by a deeply nested call chain, there is often some other synchronization mechanism involved that the analysis cannot interpret, so the resulting reports are often false positives. By default, if a second lock is acquired in a call chain that has more than 6 getlock calls, the analysis will not treat it as a lock acquired when holding another lock. As a consequence, it might suppress an C/C++ defect that is associated with that pair. To find such an issue, enable this option by increasing the max_lock_depth value. Defaults to ORDER_REVERSAL:max_lock_depth:6</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>concurrency (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>OVERFLOW_BEFORE_WIDEN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>check_bitwise_operands</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker reports defects based on values that have gone through bitwise-and, bitwise-or, or bitwise-xor operations. By default, the checker treats overflow in the argument to a bitwise operator as intentional. Defaults to OVERFLOW_BEFORE_WIDEN:check_bitwise_operands:false (for C/C++, C#, and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_macros</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option option is true, the checker reports potentially overflowing operations even when they occur within macros. The checker ignores macros by default. Defaults to OVERFLOW_BEFORE_WIDEN:check_macros:false (for C/C++ only).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_nonlocals</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker reports potentially overflowing operations even when the cause of widening is nonlocal (for example, a function or method call, or a global static variable). Defaults to OVERFLOW_BEFORE_WIDEN:check_nonlocals:false (for C/C++, C#, and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_types</Name>
            <Type>regex</Type>
            <Description>This C/C++ option specifies a regular expression (Perl syntax) to match against the destination type of the existing widening operation. A defect will only be reported if the destination type matches the specified regular expression. Defaults to OVERFLOW_BEFORE_WIDEN:check_types:(?:unsigned )?long long|.*64.* (for C/C++ only).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>class_is_nonlocal</Name>
            <Type>bool</Type>
            <Description>When true, member functions and fields within the current class (C++, Java, C#) are treated as "non-local" and not used as the basis for reporting a defect. This C/C++, C#, and Java option has no effect when check_nonlocals is true.Defaults to OVERFLOW_BEFORE_WIDEN:class_is_nonlocal:false for all languages.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>ignore_types</Name>
            <Type>regex</Type>
            <Description>This C/C++ option specifies a regular expression (Perl syntax) to match against the destination type of the existing widening operation. A defect will NOT be reported if the destination type matches the specified regular expression, even if it matches the check_types regular expression. Defaults to OVERFLOW_BEFORE_WIDEN:ignore_types:s?size_t|off_t|time_t|__off64_t|ulong|.*32.* (for C/C++ only).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_intervening_widen</Name>
            <Type>bool</Type>
            <Description>If this C/C++, C#, and Java option is set to true, a widening cast between two multiplications, such as (long long)(x * x) * y, will be treated as a defect. By default, such a widening cast is treated as intentional (and not a defect) on the assumption that it is protecting the later multiplication from overflow because the programmer knows that the first one will not overflow. Defaults to OVERFLOW_BEFORE_WIDEN:report_intervening_widen:false.</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>OVERRUN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_cond_call_on_parm</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will report cases where a buffer parameter is indexed by another parameter even though the index that is passed to a function in a conditional could potentially check its range. Defaults to false. Defaults to OVERRUN:allow_cond_call_on_parm:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_range_check_on_parm</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will report defects when a buffer parameter is indexed by another parameter, even though the index has been previously range-checked against some variable (for example, a global). Defaults to OVERRUN:allow_range_check_on_parm:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_strlen</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will analyze strlen function to determine buffer size. This option is enabled by default when the allow_symbol option is set to true. Defaults to OVERRUN:allow_strlen:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_symbol</Name>
            <Type>bool</Type>
            <Description>When this option is true, the checker uses symbolic analysis to find array overruns, even when the size of the array is determined at run time. Defaults to OVERRUN:allow_symbol:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_nonsymbolic_dynamic</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will report overruns of arrays that are dynamically allocated but with fixed allocation sizes. These reports have a high false positive rate because the analysis often cannot determine the proper correlation between allocation sites and array accesses in code that uses this technique. Defaults to OVERRUN:check_nonsymbolic_dynamic:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_underrun</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports when an array is accessed with a negative index. Defaults to OVERRUN:report_underrun:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>strict_arithmetic</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports when pointer arithmetic yields an address that is before the first byte or after the last byte+1 of the buffer. Using this address as a loop bound will typically result in an overrun or underrun issue. Defaults to OVERRUN:strict_arithmetic:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>strict_member_boundaries</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports when adjacent arrays within a struct are used as a single large array (the C language does not guarantee that this is safe). Defaults to OVERRUN:strict_member_boundaries:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>OVERRUN_DYNAMIC</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_cond_call_on_parm</Name>
            <Type>bool</Type>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_range_check_on_parm</Name>
            <Type>bool</Type>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_strlen</Name>
            <Type>bool</Type>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_symbol</Name>
            <Type>bool</Type>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEPRECATED (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>OVERRUN_STATIC</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_cond_call_on_parm</Name>
            <Type>bool</Type>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_range_check_on_parm</Name>
            <Type>bool</Type>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEPRECATED (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>PARSE_ERROR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>PARSE_WARNINGS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>PASS_BY_VALUE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>catch_threshold</Name>
            <Type>int</Type>
            <Description>This C/C++ option specifies the maximum size of a catch parameter. When a catch parameter is larger, the checker will report a defect. Defaults to PASS_BY_VALUE:catch_threshold:64 (64 bytes).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>size_threshold</Name>
            <Type>int</Type>
            <Description>This C/C++ option specifies the maximum size of a function parameter. When a parameter is larger, the checker will report a defect. Defaults to PASS_BY_VALUE:size_threshold:128 (128 bytes).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>unmodified_threshold</Name>
            <Type>int</Type>
            <Description>This C/C++ option specifies the maximum size of a function parameter that is not modified inside the function. When an unmodified parameter is larger, the checker will report a defect. Defaults to PASS_BY_VALUE:unmodified_threshold:128 (128 bytes).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>READLINK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>RESOURCE_LEAK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_address_taken</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will report a leak even when the address of the resource pointer is taken. The checker does not keep track of the pointer address, so these reports have a high probability of being false positives, since the code could free the resource through the taken address later on. Defaults to RESOURCE_LEAK:allow_address_taken:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_aliasing</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option and the track_fields option are true, the checker reports a resource leak for fields of potentially aliased pointers (for example, parameters) if the pointers are freed. Setting this option to true might yield more defects, but it can also cause the analysis to slow down and report more false positives. Defaults to RESOURCE_LEAK:allow_aliasing:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_cast_to_int</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will report a leak even if the resource pointer was at some point cast to an integer. The checker does not keep track of what happens to such integers, so those reports have a high chance of being false positives because the code could cast the integer back to a pointer later. Defaults to RESOURCE_LEAK:allow_cast_to_int:false (for C/C++ only; assumes that a pointer is being aliased when it is cast).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_constructor</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option and the allow_unimpl option are true, the checker will assume that constructors do not alias arguments. Defaults to RESOURCE_LEAK:allow_constructor:false (for C/C++ only)</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_main</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will report a resource leak in a function called main. Often, a program uses memory that is freed when main returns. By default, the analysis does not report memory that is not freed in main functions. Defaults to RESOURCE_LEAK:allow_main:false (for C/C++ only)</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_overwrite_model</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option and the track_fields option are true, the checker will report a resource leak if a field that refers to a resource is overwritten in a function call. Setting this option to true might find more defects, but it can also cause the analysis to slow down and report more false positives. Defaults to RESOURCE_LEAK:allow_overwrite_model:false (for C/C++ only)</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_template</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option and the allow_unimpl option are true, the checker will assume that template functions do not alias arguments. Defaults to RESOURCE_LEAK:allow_template:false (for C/C++ only)</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_unimpl</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will assume that a function does not alias (save) or free its arguments when its implementation is unavailable to the analysis. Setting this option to true usually causes the checker to report many false positives. However, you can use the false positives to determine which free functions to model and then run an analyses that return real defects that would not have been found otherwise. Defaults to RESOURCE_LEAK:allow_unimpl:false (for C/C++ only)</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_virtual</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option and the allow_unimpl option are true, the checker will assume that virtual calls do not alias or free their arguments. Defaults to RESOURCE_LEAK:allow_virtual:false (for C/C++ only)</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>no_vararg_leak</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will not report a resource leak if a pointer is passed to a variadic function (a function that can take different numbers of arguments). The C function printf is an example of a variadic function that takes one argument that specifies the output formatting and any number of arguments providing the values to be formatted. By default, in this case, the checker reports a defect because pointers are often passed to printf, which does not prevent pointers from causing a resource leak. You might use this option if you are encountering false positives because a variadic function is freeing or aliasing parameters. Defaults to RESOURCE_LEAK:no_vararg_leak:false (for C/C++ only)</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_handles</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will report of leaks of non-pointer "handles," in addition to memory leaks. A fixed list of handle opening functions is built into the checker, most of which are POSIX functions, along with a similar list of handle closing functions. Direct user modeling using Coverity modeling primitives is not yet supported, but custom models can be written using open() and close() as the opening and closing primitives. Defaults to RESOURCE_LEAK:report_handles:true (for C/C++ only)</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>track_fields</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker will track structure fields and report resource leaks that involve resources referred to by them. Setting this to true might find more defects, but it can also cause the analysis to slow down and report more false positives. Defaults to RESOURCE_LEAK:track_fields:false (for C/C++ only)</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>RETURN_LOCAL</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>REVERSE_INULL</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>REVERSE_NEGATIVE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SECURE_CODING</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEPRECATED (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SECURE_TEMP</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SELF_ASSIGN</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>rule (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SIGN_EXTENSION</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>require_unsigned_dest</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, the result type of the sign-extending cast must be unsigned in order to be reported as a defect. Defaults to SIGN_EXTENSION:require_unsigned_dest:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SIZECHECK</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>ampersand_in_size</Name>
            <Type>bool</Type>
            <Description>C/C++ option that finds defects where the memory allocated is calculated using the bitwise AND operator (&amp;) and two quantities. Defaults to SIZECHECK:ampersand_in_size:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>improper_new</Name>
            <Type>bool</Type>
            <Description>C/C++ option that finds defects where the wrong syntax for new() is used. Defaults to SIZECHECK:improper_new:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>incorrect_multiplication</Name>
            <Type>bool</Type>
            <Description>C/C++ option that finds defects where the memory allocated is calculated using a multiple of a constant that is not the same size as the pointer's target type. Defaults to SIZECHECK:incorrect_multiplication:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEPRECATED (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SIZEOF_MISMATCH</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>strict_memcpy</Name>
            <Type>bool</Type>
            <Description>If this C/C++ option option is set to true, the checker reports a defect for a mismatch between the function arguments of memcpy(dest, src, n). The mismatch can occur between n and dest or between n and src. Defaults to SIZEOF_MISMATCH:strict_memcpy:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SLEEP</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>concurrency (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STACK_USE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>alignment_bytes</Name>
            <Type>int</Type>
            <Description>This C/C++ option specifies the minimum allocation alignment for objects on the stack. All stack allocations are promoted to a multiple of this boundary. It must be a power of two (1 is allowed). The prologue usage is also promoted to the nearest multiple of the alignment boundary if not explicitly specified. Defaults to STACK_USE:alignment_bytes:4</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>max_single_base_use_bytes</Name>
            <Type>int</Type>
            <Description>This C/C++ option specifies the maximum number of bytes allowed for a single stack allocation (for example, one local declaration) before that allocation, by itself, will be reported as a defect. Any specified value is promoted to a multiple of the alignment boundary. Defaults to STACK_USE:max_single_base_use_bytes:10000</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>max_total_use_bytes</Name>
            <Type>int</Type>
            <Description>This C/C++ option specifies the maximum number of bytes allowed for total stack allocation before that aggregate allocation is reported as a defect. Any specified value is promoted to a multiple of the alignment boundary. Defaults to STACK_USE:max_total_use_bytes:250000</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>note_direct_recursion</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports a defect whenever it sees a function that indirectly calls itself. This checker does not include any stack usage in its calculations for recursive calls. Defaults to STACK_USE:note_direct_recursion:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>note_indirect_recursion</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports a defect on each indirect recursion that it finds. This checker does not include any stack usage in its calculations for recursive calls. Defaults to STACK_USE:note_direct_recursion:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>note_indirection</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports a defect when a function call through indirection (function pointers) is seen. This checker does not include any stack usage in its calculations for indirect calls. Defaults to STACK_USE:note_indirection:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>note_max_use</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports a defect for the function with highest stack usage in the code base. Defaults to STACK_USE:note_max_use:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>prologue_use_bytes</Name>
            <Type>int</Type>
            <Description>This C/C++ option specifies the amount of stack usage added to any function that has any other stack usage (for example, a local declaration). It must be zero or a power of two that is a multiple of the alignment boundary. If the alignment boundary is not explicitly specified and is not appropriate for the specified prologue usage, the alignment boundary will be set to half of the prologue usage or 1, whichever is more. Defaults to STACK_USE:prologue_use_bytes:16</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>reuse_stack</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker assumes that stack space is reused by non-overlapping scopes. Whether that is true or not depends on the compiler and the optimization settings. Defaults to STACK_USE:reuse_stack:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STRAY_SEMICOLON</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STREAM_FORMAT_STATE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_suspicious_setf_args</Name>
            <Type>bool</Type>
            <Description>When this C++ option is true, the checker will report cases where it cannot properly interpret the mask that is passed to setf and therefore cannot determine whether the code is correct. Proper handling of setf (and unsetf) requires understanding what bits are set in the argument mask. Defaults to STREAM_FORMAT_STATE:report_suspicious_setf_args:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>saver_class_regex</Name>
            <Type>regex</Type>
            <Description>This C++ option specifies a regular expression that matches a class name. The checker will not report any unsaved settings for a stream that is passed as the first argument of a constructor for a class whose simple identifier (no qualifiers) matches (including substring match) this regular expression. The purpose of this option is to handle cases where the formatting flags are saved in a stack-allocated object that restores those flags in its destructor. Defaults to STREAM_FORMAT_STATE:saver_class_regex:saver$</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STRING_NULL</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STRING_OVERFLOW</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_fixed_size_dest</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports defects if the destination size is known, but the source size is not (for example, a pointer). These are potential overflows because the source could be arbitrarily large and should be length checked before being passed to the copy routine. When set to false, defects are not reported unless both source and destination sizes are known. Defaults to STRING_OVERFLOW:report_fixed_size_dest:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>STRING_SIZE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SWAPPED_ARGUMENTS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>callee_name_has</Name>
            <Type>regex</Type>
            <Description>For this C/C++, C#, Java option, the checker will not report a defect if the regular expression matches in the simple function name of the callee (class, package, and namespace name not included). Defaults to SWAPPED_ARGUMENTS:callee_name_has:[eE]qual</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>caller_name_has</Name>
            <Type>regex</Type>
            <Description>For this C/C++, C#, Java option, the checker will not report a defect if the regular expression matches in the simple function name or simple class name of the caller (where defect is reported; package and namespace names not included). Defaults to SWAPPED_ARGUMENTS:caller_name_has:verse|vert|[sS]wap|[uU]ndo|[eE]xchange|[rR]otate|[tT]rans</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>TAINTED_SCALAR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>tainting_byteswaps</Name>
            <Type>bool</Type>
            <Description>If this C/C++ option is set to true, the checker will treat buffers used to load integers one byte at a time as defects. Defaults to TAINTED_SCALAR:tainting_byteswaps:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>TAINTED_STRING</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>paranoid_format</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, the checker reports a defect when a non-constant string is used as a format string argument. It addresses the case where Coverity Analysis does not track the propagation of tainted string, which typically occurs once the string flows through a global variable. For a format string vulnerability, adding a correct format specifier (usually "%s") as the format string argument usually alleviates the problem. Defaults to TAINTED_STRING:paranoid_format:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>TOCTOU</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>security (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNCAUGHT_EXCEPT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>except_ignore</Name>
            <Type>regex</Type>
            <Description>C++ option that excludes matching unqualified identifiers that escape a root function. The checker excludes an exception from the defect report if the pattern matches a class identifier for the exception. Default is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>except_report</Name>
            <Type>regex</Type>
            <Description>C++ option that finds matching unqualified identifiers that escape a root function. The checker includes an exception within the defect report if the pattern matches the class identifier for the exception. Default is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>follow_indirect_calls</Name>
            <Type>bool</Type>
            <Description>When this C++ option is true, and either virtual function call tracking and/or function pointer tracking are enabled, UNCAUGHT_EXCEPT will follow such indirect calls for the purpose of propagating thrown exceptions. When false, exceptions are not considered to propagate across indirect calls, even when indirect call tracking is otherwise enabled. Defaults to UNCAUGHT_EXCEPT:follow_indirect_calls:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>fun_ignore</Name>
            <Type>regex</Type>
            <Description>C++ option that excludes an exception from a defect report if it results from a function that partially or fully matches the specified value. You specify function identifiers in the same was as you specify them for fun_report. Default is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>fun_report</Name>
            <Type>regex</Type>
            <Description>C++ option that specifies a partially or completely matching function identifier. The checker treats the value to this option as an unanchored regular expression. That is, a single identifier causes a full match, while a regular expression metacharacter yields a partial match. Default is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_all_fun</Name>
            <Type>bool</Type>
            <Description>When this C++ option is set to true, it enables the reporting of exceptions for all functions that are not called by other functions. Defaults to UNCAUGHT_EXCEPT:report_all_fun:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_exn_spec</Name>
            <Type>bool</Type>
            <Description>When this C++ option is set to false, it disables reporting of exception-specification violations. Defaults to UNCAUGHT_EXCEPT:report_exn_spec:true</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_thrown_pointers</Name>
            <Type>bool</Type>
            <Description>When this C++ option is set to true, the checker reports an error when any pointer is thrown. In C++, throwing by value is recommended, while throwing by pointer discouraged. Defaults to UNCAUGHT_EXCEPT:report_thrown_pointers:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNINIT</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_unimpl</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, UNINIT assumes that an unimplemented function does not do any initialization. Defaults to UNINIT:allow_unimpl:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_arguments</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, UNINIT reports a defect if the arguments to any function are uninitialized. Defaults to UNINIT:check_arguments:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_malloc_wrappers</Name>
            <Type>bool</Type>
            <Description>By default, UNINIT tracks dynamic memory allocated with calls to malloc() or new(). However, UNINIT does not track memory allocated by wrappers around malloc() or new(). UNINIT also does not track the memory of a variable whose address is passed to callees and where the callee then allocates memory to the address. With this C/C++ option enabled, UNINIT tracks this memory and reports defects if it is used without initialization. A higher rate of false positives can occur because UNINIT cannot identify the memory that these wrappers or allocating functions have allocated and initialized. Defaults to UNINIT:check_malloc_wrappers:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>check_mayreads</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, UNINIT reports defects on fields of structs that might be read along a path in a called function. Defaults to UNINIT:check_mayreads:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_deep_read_models</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option option is set to true, UNINIT does a deeper interprocedural analysis: It tracks variable uses at callee depths greater than 1. This can increase the number of reported defects but can also result in more false positives because of inadequacies in tracking interprocedural contexts. Defaults to UNINIT:enable_deep_read_models:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_parm_context_reads</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is set to true, UNINIT reports defects on uninitialized fields of structs within callees that are conditioned on constraints on other parameter values. Defaults to UNINIT:enable_parm_context_reads:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>enable_write_context</Name>
            <Type>bool</Type>
            <Description>By default, UNINIT does not distinguish the interprocedural context under which a callee can initialize a parameter or parameter field. To avoid too many false positives, UNINIT does not report a defect if it finds an initialization of a parameter along at least one path in the callee. This C/C++ option relaxes this restriction and tracks the context of interprocedural initializations. The checker reports more defects and possibly more false positives because of approximations in interprocedural context tracking. Defaults to UNINIT:enable_write_context:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNINIT_CTOR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_unimpl</Name>
            <Type>bool</Type>
            <Description>When this C++ option is true, the checker treats unimplemented functions as though they do not initialize anything. Defaults to false.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>ctor_func</Name>
            <Type>string_list</Type>
            <Description>This C++ option specifies a set of method names, as simple identifiers (no scope qualifiers, no parameter types), to treat as if they were constructors. If a class has at least one method with a name in this set, then the methods with such names are checked to make sure they initialize all members (regardless of the ignore_empty_constructors and ignore_priv_prot_constructors options), and the actual constructors are not checked. This option is useful when the code base contains some classes that have a dedicated init or similar method that plays the role of a constructor, and the actual constructor does nothing. Default is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>ignore_array_members</Name>
            <Type>bool</Type>
            <Description>When this C++ option is true, the checker will not report defects in array fields that are not initialized in the constructor. Defaults to UNINIT_CTOR:ignore_array_members:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>ignore_empty_constructors</Name>
            <Type>bool</Type>
            <Description>When this C++ option is true, the checker will not report defects in empty constructors. Defaults to UNINIT_CTOR:ignore_empty_constructors:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>ignore_priv_prot_constructors</Name>
            <Type>bool</Type>
            <Description>When this C++ option is true, the checker will not report defects in private and protected constructors. Defaults to UNINIT_CTOR:ignore_priv_prot_constructors:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_compiler_bugs</Name>
            <Type>bool</Type>
            <Description>When this C++ option is true, the checker will report when a member should be value-initialized according to the C++ language rules, but some compilers will leave it uninitialized due to bugs on those compilers. When the option is false, the checker will not report them. When it is unset, the checker will report such members if the native compiler appears to be a version that has the bug, as determined when the compiler was configured by cov-configure or cov-build. Default is unset.</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_scalar_arrays</Name>
            <Type>bool</Type>
            <Description>When true, this C++ option turns on tracking of scalar 1-dimensional (1-D) arrays. Aggressiveness levels of medium and above also turn on tracking of these arrays. Note that 2-D arrays are never tracked. Defaults to UNINIT_CTOR:report_scalar_arrays:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNINTENDED_INTEGER_DIVISION</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNREACHABLE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>report_unreachable_empty_increment</Name>
            <Type>bool</Type>
            <Description>This C/C++, C#, and Java option reports a defect when a loop increment is both empty and unreachable, and the loop body does not execute more than once. Defaults to UNREACHABLE:report_unreachable_empty_increment:true (for C/C++). Defaults to UNREACHABLE:report_unreachable_empty_increment:false (for C# and Java).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_unreachable_in_macro</Name>
            <Type>bool</Type>
            <Description>This C/C++ option reports a defect when a code block is unreachable due to a macro expansion. Defaults to UNREACHABLE:report_unreachable_empty_increment:false (for C/C++ only).</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++, C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>UNUSED_VALUE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>defects_threshold_on_var</Name>
            <Type>int</Type>
            <Description>In some coding environments, a variable will be intentionally assigned values many times without being used. This C/C++, C#, and Java option sets a threshold for the number of defects above which no defect will be reported for assignments to the same variable. This option can take a value from 1 to 99. Defaults to UNUSED_VALUE:defect_threshold_on_var:2</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_dominating_assignment</Name>
            <Type>bool</Type>
            <Description>By default, the checker does not report cases where all the control flow paths that overwrite a value also contain the former assignment of this value to a variable. The assignment is said to dominate the value overwrite. When this C/C++, C#, and Java option is true, such cases will be reported as defects, but it can also cause the checker to report some instances where a program defensively initializes a variable and then reassigns it without ever using the initializing value. Defaults to UNUSED_VALUE:report_dominating_assignment:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_never_read_variable</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker will report cases where a variable is assigned one or more values but none are used. Defaults to UNUSED_VALUE:report_never_read_variable:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_overwritten_initializer</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker will report cases where a value that initialized a variable is overwritten before it is used. Defaults to UNUSED_VALUE:report_overwritten_initializer:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_unused_final_assignment</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker will report cases where a variable is assigned a final value, but that value is never used before the variable goes out of scope. Defaults to UNUSED_VALUE:report_unused_final_assignment:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>report_unused_initializer</Name>
            <Type>bool</Type>
            <Description>When this C/C++, C#, and Java option is true, the checker will report cases where a value that initialized a variable is never used or overwritten. Defaults to UNUSED_VALUE:report_unused_initializer:false</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
              <CheckerLanguage>cs</CheckerLanguage>
              <CheckerLanguage>java</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>USE_AFTER_FREE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>allow_report_args</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports a defect when a freed pointer is passed to a function. If you set this option to false, the checker will report a defect on the passing of a freed pointer only if the function is known to free or dereference it. Note that if you re-enable this option, existing defects are not affected: defects from different analysis runs will be merged properly. Defaults to USE_AFTER_FREE:allow_report_args:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>allow_simple_use</Name>
            <Type>bool</Type>
            <Description>When this C/C++ option is true, the checker reports a defect when a freed pointer reappears in the code. Defaults to USE_AFTER_FREE:allow_simple_use:true</Description>
            <Languages>
              <CheckerLanguage>c</CheckerLanguage>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>USER_POINTER</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>VARARGS</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>DEFAULT (C, C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>VIRTUAL_DTOR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>ignore_empty_dtors</Name>
            <Type>bool</Type>
            <Description>When this C++ option is true, the checker will treat an empty destructor the same as an implicitly defined destructor. Defaults to VIRTUAL_DTOR:ignore_empty_dtors:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>OPTIONAL (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>VOLATILE_ATOMICITY</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>OPTIONAL (C#)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>WRAPPER_ESCAPE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>true</Active>
        <Locked>false</Locked>
        <Sdk>false</Sdk>
        <Options>
          <CheckerOption>
            <Name>escape_locals_only</Name>
            <Type>bool</Type>
            <Description>When this C++ option is set to true, the checker will only report defects if the internal representation escapes from a stack-allocated object. Defaults to WRAPPER_ESCAPE:escape_locals_only:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
          <CheckerOption>
            <Name>skip_AddRef_callers</Name>
            <Type>bool</Type>
            <Description>When this C++ option is set to true, the checker will not report a defect on any function that calls the AddRef() method. This option exists to work around false positives caused when the checker fails to properly interpret a reference counting idiom. Defaults to WRAPPER_ESCAPE:skip_AddRef_callers:false</Description>
            <Languages>
              <CheckerLanguage>cpp</CheckerLanguage>
            </Languages>
          </CheckerOption>
        </Options>
        <Languages />
        <Tags>
          <string>DEFAULT (C++)</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BADOPAMP</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>true</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>SDK</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>BAD_OPERATOR</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>true</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>SDK</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>IMPROPER_SYSFREESTRING</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>true</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>SDK</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SETTINGPERSISTENTDATAMUSTFOLLOWUPDATE</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>true</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>SDK</string>
        </Tags>
      </Checker>
      <Checker>
        <Name>SMART_POINTER</Name>
        <AnalysisType>CppCSharp</AnalysisType>
        <Active>false</Active>
        <Locked>false</Locked>
        <Sdk>true</Sdk>
        <Options />
        <Languages />
        <Tags>
          <string>SDK</string>
        </Tags>
      </Checker>
    </Checkers>
  </AnalysisBuildSettings>
  <CentralAnalysisEnabled>false</CentralAnalysisEnabled>
  <StripPaths>
    <RemoteStripPaths />
    <LocalStripPaths />
  </StripPaths>
  <LocalAnalysisCores>1</LocalAnalysisCores>
  <UseGlobalRemoteSettings>true</UseGlobalRemoteSettings>
  <SolutionFiles />
  <UseSolutionBuildSettings>false</UseSolutionBuildSettings>
  <BuildSettingsOverridenFirstTime>false</BuildSettingsOverridenFirstTime>
</Coverity.Prevent.Desktop.Configuration>